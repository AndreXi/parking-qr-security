schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Buildings in the same residential complex"""
type buildings {
  created_at: timestamptz
  id: Int!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "buildings"
"""
type buildings_aggregate {
  aggregate: buildings_aggregate_fields
  nodes: [buildings!]!
}

"""
aggregate fields of "buildings"
"""
type buildings_aggregate_fields {
  avg: buildings_avg_fields
  count(columns: [buildings_select_column!], distinct: Boolean): Int!
  max: buildings_max_fields
  min: buildings_min_fields
  stddev: buildings_stddev_fields
  stddev_pop: buildings_stddev_pop_fields
  stddev_samp: buildings_stddev_samp_fields
  sum: buildings_sum_fields
  var_pop: buildings_var_pop_fields
  var_samp: buildings_var_samp_fields
  variance: buildings_variance_fields
}

"""aggregate avg on columns"""
type buildings_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "buildings". All fields are combined with a logical 'AND'.
"""
input buildings_bool_exp {
  _and: [buildings_bool_exp!]
  _not: buildings_bool_exp
  _or: [buildings_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "buildings"
"""
enum buildings_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  buildings_name_key

  """
  unique or primary key constraint on columns "id"
  """
  buildings_pkey
}

"""
input type for incrementing numeric columns in table "buildings"
"""
input buildings_inc_input {
  id: Int
}

"""
input type for inserting data into table "buildings"
"""
input buildings_insert_input {
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type buildings_max_fields {
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type buildings_min_fields {
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "buildings"
"""
type buildings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buildings!]!
}

"""
input type for inserting object relation for remote table "buildings"
"""
input buildings_obj_rel_insert_input {
  data: buildings_insert_input!

  """upsert condition"""
  on_conflict: buildings_on_conflict
}

"""
on_conflict condition type for table "buildings"
"""
input buildings_on_conflict {
  constraint: buildings_constraint!
  update_columns: [buildings_update_column!]! = []
  where: buildings_bool_exp
}

"""Ordering options when selecting data from "buildings"."""
input buildings_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: buildings"""
input buildings_pk_columns_input {
  id: Int!
}

"""
select columns of table "buildings"
"""
enum buildings_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "buildings"
"""
input buildings_set_input {
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type buildings_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type buildings_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type buildings_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "buildings"
"""
input buildings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: buildings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input buildings_stream_cursor_value_input {
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type buildings_sum_fields {
  id: Int
}

"""
update columns of table "buildings"
"""
enum buildings_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input buildings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: buildings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: buildings_set_input

  """filter the rows which have to be updated"""
  where: buildings_bool_exp!
}

"""aggregate var_pop on columns"""
type buildings_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type buildings_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type buildings_variance_fields {
  id: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""Locations of storages and parking slots"""
type locations {
  description: String
  has_parking_slots: Boolean!
  has_storages: Boolean!
  id: Int!
  name: String!
}

"""
aggregated selection of "locations"
"""
type locations_aggregate {
  aggregate: locations_aggregate_fields
  nodes: [locations!]!
}

"""
aggregate fields of "locations"
"""
type locations_aggregate_fields {
  avg: locations_avg_fields
  count(columns: [locations_select_column!], distinct: Boolean): Int!
  max: locations_max_fields
  min: locations_min_fields
  stddev: locations_stddev_fields
  stddev_pop: locations_stddev_pop_fields
  stddev_samp: locations_stddev_samp_fields
  sum: locations_sum_fields
  var_pop: locations_var_pop_fields
  var_samp: locations_var_samp_fields
  variance: locations_variance_fields
}

"""aggregate avg on columns"""
type locations_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "locations". All fields are combined with a logical 'AND'.
"""
input locations_bool_exp {
  _and: [locations_bool_exp!]
  _not: locations_bool_exp
  _or: [locations_bool_exp!]
  description: String_comparison_exp
  has_parking_slots: Boolean_comparison_exp
  has_storages: Boolean_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "locations"
"""
enum locations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  locations_pkey
}

"""
input type for incrementing numeric columns in table "locations"
"""
input locations_inc_input {
  id: Int
}

"""
input type for inserting data into table "locations"
"""
input locations_insert_input {
  description: String
  has_parking_slots: Boolean
  has_storages: Boolean
  id: Int
  name: String
}

"""aggregate max on columns"""
type locations_max_fields {
  description: String
  id: Int
  name: String
}

"""aggregate min on columns"""
type locations_min_fields {
  description: String
  id: Int
  name: String
}

"""
response of any mutation on the table "locations"
"""
type locations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [locations!]!
}

"""
on_conflict condition type for table "locations"
"""
input locations_on_conflict {
  constraint: locations_constraint!
  update_columns: [locations_update_column!]! = []
  where: locations_bool_exp
}

"""Ordering options when selecting data from "locations"."""
input locations_order_by {
  description: order_by
  has_parking_slots: order_by
  has_storages: order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: locations"""
input locations_pk_columns_input {
  id: Int!
}

"""
select columns of table "locations"
"""
enum locations_select_column {
  """column name"""
  description

  """column name"""
  has_parking_slots

  """column name"""
  has_storages

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "locations"
"""
input locations_set_input {
  description: String
  has_parking_slots: Boolean
  has_storages: Boolean
  id: Int
  name: String
}

"""aggregate stddev on columns"""
type locations_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type locations_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type locations_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "locations"
"""
input locations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: locations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input locations_stream_cursor_value_input {
  description: String
  has_parking_slots: Boolean
  has_storages: Boolean
  id: Int
  name: String
}

"""aggregate sum on columns"""
type locations_sum_fields {
  id: Int
}

"""
update columns of table "locations"
"""
enum locations_update_column {
  """column name"""
  description

  """column name"""
  has_parking_slots

  """column name"""
  has_storages

  """column name"""
  id

  """column name"""
  name
}

input locations_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: locations_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: locations_set_input

  """filter the rows which have to be updated"""
  where: locations_bool_exp!
}

"""aggregate var_pop on columns"""
type locations_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type locations_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type locations_variance_fields {
  id: Float
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "buildings"
  """
  delete_buildings(
    """filter the rows which have to be deleted"""
    where: buildings_bool_exp!
  ): buildings_mutation_response

  """
  delete single row from the table: "buildings"
  """
  delete_buildings_by_pk(id: Int!): buildings

  """
  delete data from the table: "locations"
  """
  delete_locations(
    """filter the rows which have to be deleted"""
    where: locations_bool_exp!
  ): locations_mutation_response

  """
  delete single row from the table: "locations"
  """
  delete_locations_by_pk(id: Int!): locations

  """
  delete data from the table: "owners"
  """
  delete_owners(
    """filter the rows which have to be deleted"""
    where: owners_bool_exp!
  ): owners_mutation_response

  """
  delete single row from the table: "owners"
  """
  delete_owners_by_pk(id: uuid!): owners

  """
  delete data from the table: "parking_slots"
  """
  delete_parking_slots(
    """filter the rows which have to be deleted"""
    where: parking_slots_bool_exp!
  ): parking_slots_mutation_response

  """
  delete single row from the table: "parking_slots"
  """
  delete_parking_slots_by_pk(id: Int!): parking_slots

  """
  delete data from the table: "storages"
  """
  delete_storages(
    """filter the rows which have to be deleted"""
    where: storages_bool_exp!
  ): storages_mutation_response

  """
  delete single row from the table: "storages"
  """
  delete_storages_by_pk(id: Int!): storages

  """
  delete data from the table: "system.roles"
  """
  delete_system_roles(
    """filter the rows which have to be deleted"""
    where: system_roles_bool_exp!
  ): system_roles_mutation_response

  """
  delete single row from the table: "system.roles"
  """
  delete_system_roles_by_pk(id: Int!): system_roles

  """
  delete data from the table: "system.users"
  """
  delete_system_users(
    """filter the rows which have to be deleted"""
    where: system_users_bool_exp!
  ): system_users_mutation_response

  """
  delete single row from the table: "system.users"
  """
  delete_system_users_by_pk(id: uuid!): system_users

  """
  delete data from the table: "vehicles"
  """
  delete_vehicles(
    """filter the rows which have to be deleted"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  delete single row from the table: "vehicles"
  """
  delete_vehicles_by_pk(id: Int!): vehicles

  """
  insert data into the table: "buildings"
  """
  insert_buildings(
    """the rows to be inserted"""
    objects: [buildings_insert_input!]!

    """upsert condition"""
    on_conflict: buildings_on_conflict
  ): buildings_mutation_response

  """
  insert a single row into the table: "buildings"
  """
  insert_buildings_one(
    """the row to be inserted"""
    object: buildings_insert_input!

    """upsert condition"""
    on_conflict: buildings_on_conflict
  ): buildings

  """
  insert data into the table: "locations"
  """
  insert_locations(
    """the rows to be inserted"""
    objects: [locations_insert_input!]!

    """upsert condition"""
    on_conflict: locations_on_conflict
  ): locations_mutation_response

  """
  insert a single row into the table: "locations"
  """
  insert_locations_one(
    """the row to be inserted"""
    object: locations_insert_input!

    """upsert condition"""
    on_conflict: locations_on_conflict
  ): locations

  """
  insert data into the table: "owners"
  """
  insert_owners(
    """the rows to be inserted"""
    objects: [owners_insert_input!]!

    """upsert condition"""
    on_conflict: owners_on_conflict
  ): owners_mutation_response

  """
  insert a single row into the table: "owners"
  """
  insert_owners_one(
    """the row to be inserted"""
    object: owners_insert_input!

    """upsert condition"""
    on_conflict: owners_on_conflict
  ): owners

  """
  insert data into the table: "parking_slots"
  """
  insert_parking_slots(
    """the rows to be inserted"""
    objects: [parking_slots_insert_input!]!

    """upsert condition"""
    on_conflict: parking_slots_on_conflict
  ): parking_slots_mutation_response

  """
  insert a single row into the table: "parking_slots"
  """
  insert_parking_slots_one(
    """the row to be inserted"""
    object: parking_slots_insert_input!

    """upsert condition"""
    on_conflict: parking_slots_on_conflict
  ): parking_slots

  """
  insert data into the table: "storages"
  """
  insert_storages(
    """the rows to be inserted"""
    objects: [storages_insert_input!]!

    """upsert condition"""
    on_conflict: storages_on_conflict
  ): storages_mutation_response

  """
  insert a single row into the table: "storages"
  """
  insert_storages_one(
    """the row to be inserted"""
    object: storages_insert_input!

    """upsert condition"""
    on_conflict: storages_on_conflict
  ): storages

  """
  insert data into the table: "system.roles"
  """
  insert_system_roles(
    """the rows to be inserted"""
    objects: [system_roles_insert_input!]!

    """upsert condition"""
    on_conflict: system_roles_on_conflict
  ): system_roles_mutation_response

  """
  insert a single row into the table: "system.roles"
  """
  insert_system_roles_one(
    """the row to be inserted"""
    object: system_roles_insert_input!

    """upsert condition"""
    on_conflict: system_roles_on_conflict
  ): system_roles

  """
  insert data into the table: "system.users"
  """
  insert_system_users(
    """the rows to be inserted"""
    objects: [system_users_insert_input!]!

    """upsert condition"""
    on_conflict: system_users_on_conflict
  ): system_users_mutation_response

  """
  insert a single row into the table: "system.users"
  """
  insert_system_users_one(
    """the row to be inserted"""
    object: system_users_insert_input!

    """upsert condition"""
    on_conflict: system_users_on_conflict
  ): system_users

  """
  insert data into the table: "vehicles"
  """
  insert_vehicles(
    """the rows to be inserted"""
    objects: [vehicles_insert_input!]!

    """upsert condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles_mutation_response

  """
  insert a single row into the table: "vehicles"
  """
  insert_vehicles_one(
    """the row to be inserted"""
    object: vehicles_insert_input!

    """upsert condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles

  """
  update data of the table: "buildings"
  """
  update_buildings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buildings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buildings_set_input

    """filter the rows which have to be updated"""
    where: buildings_bool_exp!
  ): buildings_mutation_response

  """
  update single row of the table: "buildings"
  """
  update_buildings_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buildings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buildings_set_input
    pk_columns: buildings_pk_columns_input!
  ): buildings

  """
  update multiples rows of table: "buildings"
  """
  update_buildings_many(
    """updates to execute, in order"""
    updates: [buildings_updates!]!
  ): [buildings_mutation_response]

  """
  update data of the table: "locations"
  """
  update_locations(
    """increments the numeric columns with given value of the filtered values"""
    _inc: locations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: locations_set_input

    """filter the rows which have to be updated"""
    where: locations_bool_exp!
  ): locations_mutation_response

  """
  update single row of the table: "locations"
  """
  update_locations_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: locations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: locations_set_input
    pk_columns: locations_pk_columns_input!
  ): locations

  """
  update multiples rows of table: "locations"
  """
  update_locations_many(
    """updates to execute, in order"""
    updates: [locations_updates!]!
  ): [locations_mutation_response]

  """
  update data of the table: "owners"
  """
  update_owners(
    """increments the numeric columns with given value of the filtered values"""
    _inc: owners_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: owners_set_input

    """filter the rows which have to be updated"""
    where: owners_bool_exp!
  ): owners_mutation_response

  """
  update single row of the table: "owners"
  """
  update_owners_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: owners_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: owners_set_input
    pk_columns: owners_pk_columns_input!
  ): owners

  """
  update multiples rows of table: "owners"
  """
  update_owners_many(
    """updates to execute, in order"""
    updates: [owners_updates!]!
  ): [owners_mutation_response]

  """
  update data of the table: "parking_slots"
  """
  update_parking_slots(
    """increments the numeric columns with given value of the filtered values"""
    _inc: parking_slots_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: parking_slots_set_input

    """filter the rows which have to be updated"""
    where: parking_slots_bool_exp!
  ): parking_slots_mutation_response

  """
  update single row of the table: "parking_slots"
  """
  update_parking_slots_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: parking_slots_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: parking_slots_set_input
    pk_columns: parking_slots_pk_columns_input!
  ): parking_slots

  """
  update multiples rows of table: "parking_slots"
  """
  update_parking_slots_many(
    """updates to execute, in order"""
    updates: [parking_slots_updates!]!
  ): [parking_slots_mutation_response]

  """
  update data of the table: "storages"
  """
  update_storages(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storages_set_input

    """filter the rows which have to be updated"""
    where: storages_bool_exp!
  ): storages_mutation_response

  """
  update single row of the table: "storages"
  """
  update_storages_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: storages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: storages_set_input
    pk_columns: storages_pk_columns_input!
  ): storages

  """
  update multiples rows of table: "storages"
  """
  update_storages_many(
    """updates to execute, in order"""
    updates: [storages_updates!]!
  ): [storages_mutation_response]

  """
  update data of the table: "system.roles"
  """
  update_system_roles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: system_roles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: system_roles_set_input

    """filter the rows which have to be updated"""
    where: system_roles_bool_exp!
  ): system_roles_mutation_response

  """
  update single row of the table: "system.roles"
  """
  update_system_roles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: system_roles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: system_roles_set_input
    pk_columns: system_roles_pk_columns_input!
  ): system_roles

  """
  update multiples rows of table: "system.roles"
  """
  update_system_roles_many(
    """updates to execute, in order"""
    updates: [system_roles_updates!]!
  ): [system_roles_mutation_response]

  """
  update data of the table: "system.users"
  """
  update_system_users(
    """increments the numeric columns with given value of the filtered values"""
    _inc: system_users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: system_users_set_input

    """filter the rows which have to be updated"""
    where: system_users_bool_exp!
  ): system_users_mutation_response

  """
  update single row of the table: "system.users"
  """
  update_system_users_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: system_users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: system_users_set_input
    pk_columns: system_users_pk_columns_input!
  ): system_users

  """
  update multiples rows of table: "system.users"
  """
  update_system_users_many(
    """updates to execute, in order"""
    updates: [system_users_updates!]!
  ): [system_users_mutation_response]

  """
  update data of the table: "vehicles"
  """
  update_vehicles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vehicles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input

    """filter the rows which have to be updated"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  update single row of the table: "vehicles"
  """
  update_vehicles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vehicles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input
    pk_columns: vehicles_pk_columns_input!
  ): vehicles

  """
  update multiples rows of table: "vehicles"
  """
  update_vehicles_many(
    """updates to execute, in order"""
    updates: [vehicles_updates!]!
  ): [vehicles_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""Owners of slots and vehicles"""
type owners {
  apto: String!

  """An object relationship"""
  building: buildings!
  building_id: Int!
  ci: String!
  created_at: timestamptz!
  email: String
  first_name: String!
  floor: String!
  id: uuid!
  last_name: String!

  """An array relationship"""
  parking_slots(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): [parking_slots!]!

  """An aggregate relationship"""
  parking_slots_aggregate(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): parking_slots_aggregate!
  phone: String!
  phone_1: String

  """An array relationship"""
  rented_parking_slots(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): [parking_slots!]!

  """An aggregate relationship"""
  rented_parking_slots_aggregate(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): parking_slots_aggregate!

  """An array relationship"""
  rented_stores(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): [storages!]!

  """An aggregate relationship"""
  rented_stores_aggregate(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): storages_aggregate!

  """An array relationship"""
  stores(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): [storages!]!

  """An aggregate relationship"""
  stores_aggregate(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): storages_aggregate!
  updated_at: timestamptz!

  """An array relationship"""
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """An aggregate relationship"""
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!
}

"""
aggregated selection of "owners"
"""
type owners_aggregate {
  aggregate: owners_aggregate_fields
  nodes: [owners!]!
}

"""
aggregate fields of "owners"
"""
type owners_aggregate_fields {
  avg: owners_avg_fields
  count(columns: [owners_select_column!], distinct: Boolean): Int!
  max: owners_max_fields
  min: owners_min_fields
  stddev: owners_stddev_fields
  stddev_pop: owners_stddev_pop_fields
  stddev_samp: owners_stddev_samp_fields
  sum: owners_sum_fields
  var_pop: owners_var_pop_fields
  var_samp: owners_var_samp_fields
  variance: owners_variance_fields
}

"""aggregate avg on columns"""
type owners_avg_fields {
  building_id: Float
}

"""
Boolean expression to filter rows from the table "owners". All fields are combined with a logical 'AND'.
"""
input owners_bool_exp {
  _and: [owners_bool_exp!]
  _not: owners_bool_exp
  _or: [owners_bool_exp!]
  apto: String_comparison_exp
  building: buildings_bool_exp
  building_id: Int_comparison_exp
  ci: String_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  floor: String_comparison_exp
  id: uuid_comparison_exp
  last_name: String_comparison_exp
  parking_slots: parking_slots_bool_exp
  parking_slots_aggregate: parking_slots_aggregate_bool_exp
  phone: String_comparison_exp
  phone_1: String_comparison_exp
  rented_parking_slots: parking_slots_bool_exp
  rented_parking_slots_aggregate: parking_slots_aggregate_bool_exp
  rented_stores: storages_bool_exp
  rented_stores_aggregate: storages_aggregate_bool_exp
  stores: storages_bool_exp
  stores_aggregate: storages_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  vehicles: vehicles_bool_exp
  vehicles_aggregate: vehicles_aggregate_bool_exp
}

"""
unique or primary key constraints on table "owners"
"""
enum owners_constraint {
  """
  unique or primary key constraint on columns "ci"
  """
  owners_ci_key

  """
  unique or primary key constraint on columns "id"
  """
  owners_pkey
}

"""
input type for incrementing numeric columns in table "owners"
"""
input owners_inc_input {
  building_id: Int
}

"""
input type for inserting data into table "owners"
"""
input owners_insert_input {
  apto: String
  building: buildings_obj_rel_insert_input
  building_id: Int
  ci: String
  created_at: timestamptz
  email: String
  first_name: String
  floor: String
  id: uuid
  last_name: String
  parking_slots: parking_slots_arr_rel_insert_input
  phone: String
  phone_1: String
  rented_parking_slots: parking_slots_arr_rel_insert_input
  rented_stores: storages_arr_rel_insert_input
  stores: storages_arr_rel_insert_input
  updated_at: timestamptz
  vehicles: vehicles_arr_rel_insert_input
}

"""aggregate max on columns"""
type owners_max_fields {
  apto: String
  building_id: Int
  ci: String
  created_at: timestamptz
  email: String
  first_name: String
  floor: String
  id: uuid
  last_name: String
  phone: String
  phone_1: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type owners_min_fields {
  apto: String
  building_id: Int
  ci: String
  created_at: timestamptz
  email: String
  first_name: String
  floor: String
  id: uuid
  last_name: String
  phone: String
  phone_1: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "owners"
"""
type owners_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [owners!]!
}

"""
input type for inserting object relation for remote table "owners"
"""
input owners_obj_rel_insert_input {
  data: owners_insert_input!

  """upsert condition"""
  on_conflict: owners_on_conflict
}

"""
on_conflict condition type for table "owners"
"""
input owners_on_conflict {
  constraint: owners_constraint!
  update_columns: [owners_update_column!]! = []
  where: owners_bool_exp
}

"""Ordering options when selecting data from "owners"."""
input owners_order_by {
  apto: order_by
  building: buildings_order_by
  building_id: order_by
  ci: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  floor: order_by
  id: order_by
  last_name: order_by
  parking_slots_aggregate: parking_slots_aggregate_order_by
  phone: order_by
  phone_1: order_by
  rented_parking_slots_aggregate: parking_slots_aggregate_order_by
  rented_stores_aggregate: storages_aggregate_order_by
  stores_aggregate: storages_aggregate_order_by
  updated_at: order_by
  vehicles_aggregate: vehicles_aggregate_order_by
}

"""primary key columns input for table: owners"""
input owners_pk_columns_input {
  id: uuid!
}

"""
select columns of table "owners"
"""
enum owners_select_column {
  """column name"""
  apto

  """column name"""
  building_id

  """column name"""
  ci

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  floor

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  phone

  """column name"""
  phone_1

  """column name"""
  updated_at
}

"""
input type for updating data in table "owners"
"""
input owners_set_input {
  apto: String
  building_id: Int
  ci: String
  created_at: timestamptz
  email: String
  first_name: String
  floor: String
  id: uuid
  last_name: String
  phone: String
  phone_1: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type owners_stddev_fields {
  building_id: Float
}

"""aggregate stddev_pop on columns"""
type owners_stddev_pop_fields {
  building_id: Float
}

"""aggregate stddev_samp on columns"""
type owners_stddev_samp_fields {
  building_id: Float
}

"""
Streaming cursor of the table "owners"
"""
input owners_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: owners_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input owners_stream_cursor_value_input {
  apto: String
  building_id: Int
  ci: String
  created_at: timestamptz
  email: String
  first_name: String
  floor: String
  id: uuid
  last_name: String
  phone: String
  phone_1: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type owners_sum_fields {
  building_id: Int
}

"""
update columns of table "owners"
"""
enum owners_update_column {
  """column name"""
  apto

  """column name"""
  building_id

  """column name"""
  ci

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  floor

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  phone

  """column name"""
  phone_1

  """column name"""
  updated_at
}

input owners_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: owners_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: owners_set_input

  """filter the rows which have to be updated"""
  where: owners_bool_exp!
}

"""aggregate var_pop on columns"""
type owners_var_pop_fields {
  building_id: Float
}

"""aggregate var_samp on columns"""
type owners_var_samp_fields {
  building_id: Float
}

"""aggregate variance on columns"""
type owners_variance_fields {
  building_id: Float
}

"""Parking Slots data"""
type parking_slots {
  code: String!
  created_at: timestamptz!
  id: Int!
  location_id: Int!

  """An object relationship"""
  owner: owners
  owner_id: uuid
  qr_code: uuid!
  renter_id: uuid
  updated_at: timestamptz!

  """An array relationship"""
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """An aggregate relationship"""
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!
}

"""
aggregated selection of "parking_slots"
"""
type parking_slots_aggregate {
  aggregate: parking_slots_aggregate_fields
  nodes: [parking_slots!]!
}

input parking_slots_aggregate_bool_exp {
  count: parking_slots_aggregate_bool_exp_count
}

input parking_slots_aggregate_bool_exp_count {
  arguments: [parking_slots_select_column!]
  distinct: Boolean
  filter: parking_slots_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "parking_slots"
"""
type parking_slots_aggregate_fields {
  avg: parking_slots_avg_fields
  count(columns: [parking_slots_select_column!], distinct: Boolean): Int!
  max: parking_slots_max_fields
  min: parking_slots_min_fields
  stddev: parking_slots_stddev_fields
  stddev_pop: parking_slots_stddev_pop_fields
  stddev_samp: parking_slots_stddev_samp_fields
  sum: parking_slots_sum_fields
  var_pop: parking_slots_var_pop_fields
  var_samp: parking_slots_var_samp_fields
  variance: parking_slots_variance_fields
}

"""
order by aggregate values of table "parking_slots"
"""
input parking_slots_aggregate_order_by {
  avg: parking_slots_avg_order_by
  count: order_by
  max: parking_slots_max_order_by
  min: parking_slots_min_order_by
  stddev: parking_slots_stddev_order_by
  stddev_pop: parking_slots_stddev_pop_order_by
  stddev_samp: parking_slots_stddev_samp_order_by
  sum: parking_slots_sum_order_by
  var_pop: parking_slots_var_pop_order_by
  var_samp: parking_slots_var_samp_order_by
  variance: parking_slots_variance_order_by
}

"""
input type for inserting array relation for remote table "parking_slots"
"""
input parking_slots_arr_rel_insert_input {
  data: [parking_slots_insert_input!]!

  """upsert condition"""
  on_conflict: parking_slots_on_conflict
}

"""aggregate avg on columns"""
type parking_slots_avg_fields {
  id: Float
  location_id: Float
}

"""
order by avg() on columns of table "parking_slots"
"""
input parking_slots_avg_order_by {
  id: order_by
  location_id: order_by
}

"""
Boolean expression to filter rows from the table "parking_slots". All fields are combined with a logical 'AND'.
"""
input parking_slots_bool_exp {
  _and: [parking_slots_bool_exp!]
  _not: parking_slots_bool_exp
  _or: [parking_slots_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  location_id: Int_comparison_exp
  owner: owners_bool_exp
  owner_id: uuid_comparison_exp
  qr_code: uuid_comparison_exp
  renter_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  vehicles: vehicles_bool_exp
  vehicles_aggregate: vehicles_aggregate_bool_exp
}

"""
unique or primary key constraints on table "parking_slots"
"""
enum parking_slots_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  parking_slots_code_key

  """
  unique or primary key constraint on columns "id"
  """
  parking_slots_pkey

  """
  unique or primary key constraint on columns "qr_code"
  """
  parking_slots_qr_code_key
}

"""
input type for incrementing numeric columns in table "parking_slots"
"""
input parking_slots_inc_input {
  id: Int
  location_id: Int
}

"""
input type for inserting data into table "parking_slots"
"""
input parking_slots_insert_input {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner: owners_obj_rel_insert_input
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
  vehicles: vehicles_arr_rel_insert_input
}

"""aggregate max on columns"""
type parking_slots_max_fields {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "parking_slots"
"""
input parking_slots_max_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  location_id: order_by
  owner_id: order_by
  qr_code: order_by
  renter_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type parking_slots_min_fields {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "parking_slots"
"""
input parking_slots_min_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  location_id: order_by
  owner_id: order_by
  qr_code: order_by
  renter_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "parking_slots"
"""
type parking_slots_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [parking_slots!]!
}

"""
input type for inserting object relation for remote table "parking_slots"
"""
input parking_slots_obj_rel_insert_input {
  data: parking_slots_insert_input!

  """upsert condition"""
  on_conflict: parking_slots_on_conflict
}

"""
on_conflict condition type for table "parking_slots"
"""
input parking_slots_on_conflict {
  constraint: parking_slots_constraint!
  update_columns: [parking_slots_update_column!]! = []
  where: parking_slots_bool_exp
}

"""Ordering options when selecting data from "parking_slots"."""
input parking_slots_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  location_id: order_by
  owner: owners_order_by
  owner_id: order_by
  qr_code: order_by
  renter_id: order_by
  updated_at: order_by
  vehicles_aggregate: vehicles_aggregate_order_by
}

"""primary key columns input for table: parking_slots"""
input parking_slots_pk_columns_input {
  id: Int!
}

"""
select columns of table "parking_slots"
"""
enum parking_slots_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location_id

  """column name"""
  owner_id

  """column name"""
  qr_code

  """column name"""
  renter_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "parking_slots"
"""
input parking_slots_set_input {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type parking_slots_stddev_fields {
  id: Float
  location_id: Float
}

"""
order by stddev() on columns of table "parking_slots"
"""
input parking_slots_stddev_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate stddev_pop on columns"""
type parking_slots_stddev_pop_fields {
  id: Float
  location_id: Float
}

"""
order by stddev_pop() on columns of table "parking_slots"
"""
input parking_slots_stddev_pop_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate stddev_samp on columns"""
type parking_slots_stddev_samp_fields {
  id: Float
  location_id: Float
}

"""
order by stddev_samp() on columns of table "parking_slots"
"""
input parking_slots_stddev_samp_order_by {
  id: order_by
  location_id: order_by
}

"""
Streaming cursor of the table "parking_slots"
"""
input parking_slots_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: parking_slots_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input parking_slots_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type parking_slots_sum_fields {
  id: Int
  location_id: Int
}

"""
order by sum() on columns of table "parking_slots"
"""
input parking_slots_sum_order_by {
  id: order_by
  location_id: order_by
}

"""
update columns of table "parking_slots"
"""
enum parking_slots_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location_id

  """column name"""
  owner_id

  """column name"""
  qr_code

  """column name"""
  renter_id

  """column name"""
  updated_at
}

input parking_slots_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: parking_slots_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: parking_slots_set_input

  """filter the rows which have to be updated"""
  where: parking_slots_bool_exp!
}

"""aggregate var_pop on columns"""
type parking_slots_var_pop_fields {
  id: Float
  location_id: Float
}

"""
order by var_pop() on columns of table "parking_slots"
"""
input parking_slots_var_pop_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate var_samp on columns"""
type parking_slots_var_samp_fields {
  id: Float
  location_id: Float
}

"""
order by var_samp() on columns of table "parking_slots"
"""
input parking_slots_var_samp_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate variance on columns"""
type parking_slots_variance_fields {
  id: Float
  location_id: Float
}

"""
order by variance() on columns of table "parking_slots"
"""
input parking_slots_variance_order_by {
  id: order_by
  location_id: order_by
}

type query_root {
  """
  fetch data from the table: "buildings"
  """
  buildings(
    """distinct select on columns"""
    distinct_on: [buildings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buildings_order_by!]

    """filter the rows returned"""
    where: buildings_bool_exp
  ): [buildings!]!

  """
  fetch aggregated fields from the table: "buildings"
  """
  buildings_aggregate(
    """distinct select on columns"""
    distinct_on: [buildings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buildings_order_by!]

    """filter the rows returned"""
    where: buildings_bool_exp
  ): buildings_aggregate!

  """fetch data from the table: "buildings" using primary key columns"""
  buildings_by_pk(id: Int!): buildings

  """
  fetch data from the table: "locations"
  """
  locations(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """
  fetch aggregated fields from the table: "locations"
  """
  locations_aggregate(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): locations_aggregate!

  """fetch data from the table: "locations" using primary key columns"""
  locations_by_pk(id: Int!): locations

  """
  fetch data from the table: "owners"
  """
  owners(
    """distinct select on columns"""
    distinct_on: [owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [owners_order_by!]

    """filter the rows returned"""
    where: owners_bool_exp
  ): [owners!]!

  """
  fetch aggregated fields from the table: "owners"
  """
  owners_aggregate(
    """distinct select on columns"""
    distinct_on: [owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [owners_order_by!]

    """filter the rows returned"""
    where: owners_bool_exp
  ): owners_aggregate!

  """fetch data from the table: "owners" using primary key columns"""
  owners_by_pk(id: uuid!): owners

  """An array relationship"""
  parking_slots(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): [parking_slots!]!

  """An aggregate relationship"""
  parking_slots_aggregate(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): parking_slots_aggregate!

  """fetch data from the table: "parking_slots" using primary key columns"""
  parking_slots_by_pk(id: Int!): parking_slots

  """
  fetch data from the table: "storages"
  """
  storages(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): [storages!]!

  """
  fetch aggregated fields from the table: "storages"
  """
  storages_aggregate(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): storages_aggregate!

  """fetch data from the table: "storages" using primary key columns"""
  storages_by_pk(id: Int!): storages

  """
  fetch data from the table: "system.roles"
  """
  system_roles(
    """distinct select on columns"""
    distinct_on: [system_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_roles_order_by!]

    """filter the rows returned"""
    where: system_roles_bool_exp
  ): [system_roles!]!

  """
  fetch aggregated fields from the table: "system.roles"
  """
  system_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [system_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_roles_order_by!]

    """filter the rows returned"""
    where: system_roles_bool_exp
  ): system_roles_aggregate!

  """fetch data from the table: "system.roles" using primary key columns"""
  system_roles_by_pk(id: Int!): system_roles

  """
  fetch data from the table: "system.users"
  """
  system_users(
    """distinct select on columns"""
    distinct_on: [system_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_users_order_by!]

    """filter the rows returned"""
    where: system_users_bool_exp
  ): [system_users!]!

  """
  fetch aggregated fields from the table: "system.users"
  """
  system_users_aggregate(
    """distinct select on columns"""
    distinct_on: [system_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_users_order_by!]

    """filter the rows returned"""
    where: system_users_bool_exp
  ): system_users_aggregate!

  """fetch data from the table: "system.users" using primary key columns"""
  system_users_by_pk(id: uuid!): system_users

  """An array relationship"""
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """An aggregate relationship"""
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "vehicles" using primary key columns"""
  vehicles_by_pk(id: Int!): vehicles
}

"""Table to track stores"""
type storages {
  code: String!
  created_at: timestamptz!
  id: Int!
  location_id: Int!
  owner_id: uuid
  qr_code: uuid!
  renter_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "storages"
"""
type storages_aggregate {
  aggregate: storages_aggregate_fields
  nodes: [storages!]!
}

input storages_aggregate_bool_exp {
  count: storages_aggregate_bool_exp_count
}

input storages_aggregate_bool_exp_count {
  arguments: [storages_select_column!]
  distinct: Boolean
  filter: storages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storages"
"""
type storages_aggregate_fields {
  avg: storages_avg_fields
  count(columns: [storages_select_column!], distinct: Boolean): Int!
  max: storages_max_fields
  min: storages_min_fields
  stddev: storages_stddev_fields
  stddev_pop: storages_stddev_pop_fields
  stddev_samp: storages_stddev_samp_fields
  sum: storages_sum_fields
  var_pop: storages_var_pop_fields
  var_samp: storages_var_samp_fields
  variance: storages_variance_fields
}

"""
order by aggregate values of table "storages"
"""
input storages_aggregate_order_by {
  avg: storages_avg_order_by
  count: order_by
  max: storages_max_order_by
  min: storages_min_order_by
  stddev: storages_stddev_order_by
  stddev_pop: storages_stddev_pop_order_by
  stddev_samp: storages_stddev_samp_order_by
  sum: storages_sum_order_by
  var_pop: storages_var_pop_order_by
  var_samp: storages_var_samp_order_by
  variance: storages_variance_order_by
}

"""
input type for inserting array relation for remote table "storages"
"""
input storages_arr_rel_insert_input {
  data: [storages_insert_input!]!

  """upsert condition"""
  on_conflict: storages_on_conflict
}

"""aggregate avg on columns"""
type storages_avg_fields {
  id: Float
  location_id: Float
}

"""
order by avg() on columns of table "storages"
"""
input storages_avg_order_by {
  id: order_by
  location_id: order_by
}

"""
Boolean expression to filter rows from the table "storages". All fields are combined with a logical 'AND'.
"""
input storages_bool_exp {
  _and: [storages_bool_exp!]
  _not: storages_bool_exp
  _or: [storages_bool_exp!]
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  location_id: Int_comparison_exp
  owner_id: uuid_comparison_exp
  qr_code: uuid_comparison_exp
  renter_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storages"
"""
enum storages_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  stores_code_key

  """
  unique or primary key constraint on columns "id"
  """
  stores_pkey

  """
  unique or primary key constraint on columns "qr_code"
  """
  stores_qr_code_key
}

"""
input type for incrementing numeric columns in table "storages"
"""
input storages_inc_input {
  id: Int
  location_id: Int
}

"""
input type for inserting data into table "storages"
"""
input storages_insert_input {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type storages_max_fields {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "storages"
"""
input storages_max_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  location_id: order_by
  owner_id: order_by
  qr_code: order_by
  renter_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type storages_min_fields {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "storages"
"""
input storages_min_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  location_id: order_by
  owner_id: order_by
  qr_code: order_by
  renter_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "storages"
"""
type storages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [storages!]!
}

"""
on_conflict condition type for table "storages"
"""
input storages_on_conflict {
  constraint: storages_constraint!
  update_columns: [storages_update_column!]! = []
  where: storages_bool_exp
}

"""Ordering options when selecting data from "storages"."""
input storages_order_by {
  code: order_by
  created_at: order_by
  id: order_by
  location_id: order_by
  owner_id: order_by
  qr_code: order_by
  renter_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: storages"""
input storages_pk_columns_input {
  id: Int!
}

"""
select columns of table "storages"
"""
enum storages_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location_id

  """column name"""
  owner_id

  """column name"""
  qr_code

  """column name"""
  renter_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "storages"
"""
input storages_set_input {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type storages_stddev_fields {
  id: Float
  location_id: Float
}

"""
order by stddev() on columns of table "storages"
"""
input storages_stddev_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate stddev_pop on columns"""
type storages_stddev_pop_fields {
  id: Float
  location_id: Float
}

"""
order by stddev_pop() on columns of table "storages"
"""
input storages_stddev_pop_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate stddev_samp on columns"""
type storages_stddev_samp_fields {
  id: Float
  location_id: Float
}

"""
order by stddev_samp() on columns of table "storages"
"""
input storages_stddev_samp_order_by {
  id: order_by
  location_id: order_by
}

"""
Streaming cursor of the table "storages"
"""
input storages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: storages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input storages_stream_cursor_value_input {
  code: String
  created_at: timestamptz
  id: Int
  location_id: Int
  owner_id: uuid
  qr_code: uuid
  renter_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type storages_sum_fields {
  id: Int
  location_id: Int
}

"""
order by sum() on columns of table "storages"
"""
input storages_sum_order_by {
  id: order_by
  location_id: order_by
}

"""
update columns of table "storages"
"""
enum storages_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location_id

  """column name"""
  owner_id

  """column name"""
  qr_code

  """column name"""
  renter_id

  """column name"""
  updated_at
}

input storages_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: storages_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: storages_set_input

  """filter the rows which have to be updated"""
  where: storages_bool_exp!
}

"""aggregate var_pop on columns"""
type storages_var_pop_fields {
  id: Float
  location_id: Float
}

"""
order by var_pop() on columns of table "storages"
"""
input storages_var_pop_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate var_samp on columns"""
type storages_var_samp_fields {
  id: Float
  location_id: Float
}

"""
order by var_samp() on columns of table "storages"
"""
input storages_var_samp_order_by {
  id: order_by
  location_id: order_by
}

"""aggregate variance on columns"""
type storages_variance_fields {
  id: Float
  location_id: Float
}

"""
order by variance() on columns of table "storages"
"""
input storages_variance_order_by {
  id: order_by
  location_id: order_by
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "buildings"
  """
  buildings(
    """distinct select on columns"""
    distinct_on: [buildings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buildings_order_by!]

    """filter the rows returned"""
    where: buildings_bool_exp
  ): [buildings!]!

  """
  fetch aggregated fields from the table: "buildings"
  """
  buildings_aggregate(
    """distinct select on columns"""
    distinct_on: [buildings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buildings_order_by!]

    """filter the rows returned"""
    where: buildings_bool_exp
  ): buildings_aggregate!

  """fetch data from the table: "buildings" using primary key columns"""
  buildings_by_pk(id: Int!): buildings

  """
  fetch data from the table in a streaming manner: "buildings"
  """
  buildings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [buildings_stream_cursor_input]!

    """filter the rows returned"""
    where: buildings_bool_exp
  ): [buildings!]!

  """
  fetch data from the table: "locations"
  """
  locations(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """
  fetch aggregated fields from the table: "locations"
  """
  locations_aggregate(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): locations_aggregate!

  """fetch data from the table: "locations" using primary key columns"""
  locations_by_pk(id: Int!): locations

  """
  fetch data from the table in a streaming manner: "locations"
  """
  locations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [locations_stream_cursor_input]!

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """
  fetch data from the table: "owners"
  """
  owners(
    """distinct select on columns"""
    distinct_on: [owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [owners_order_by!]

    """filter the rows returned"""
    where: owners_bool_exp
  ): [owners!]!

  """
  fetch aggregated fields from the table: "owners"
  """
  owners_aggregate(
    """distinct select on columns"""
    distinct_on: [owners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [owners_order_by!]

    """filter the rows returned"""
    where: owners_bool_exp
  ): owners_aggregate!

  """fetch data from the table: "owners" using primary key columns"""
  owners_by_pk(id: uuid!): owners

  """
  fetch data from the table in a streaming manner: "owners"
  """
  owners_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [owners_stream_cursor_input]!

    """filter the rows returned"""
    where: owners_bool_exp
  ): [owners!]!

  """An array relationship"""
  parking_slots(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): [parking_slots!]!

  """An aggregate relationship"""
  parking_slots_aggregate(
    """distinct select on columns"""
    distinct_on: [parking_slots_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parking_slots_order_by!]

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): parking_slots_aggregate!

  """fetch data from the table: "parking_slots" using primary key columns"""
  parking_slots_by_pk(id: Int!): parking_slots

  """
  fetch data from the table in a streaming manner: "parking_slots"
  """
  parking_slots_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [parking_slots_stream_cursor_input]!

    """filter the rows returned"""
    where: parking_slots_bool_exp
  ): [parking_slots!]!

  """
  fetch data from the table: "storages"
  """
  storages(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): [storages!]!

  """
  fetch aggregated fields from the table: "storages"
  """
  storages_aggregate(
    """distinct select on columns"""
    distinct_on: [storages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [storages_order_by!]

    """filter the rows returned"""
    where: storages_bool_exp
  ): storages_aggregate!

  """fetch data from the table: "storages" using primary key columns"""
  storages_by_pk(id: Int!): storages

  """
  fetch data from the table in a streaming manner: "storages"
  """
  storages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [storages_stream_cursor_input]!

    """filter the rows returned"""
    where: storages_bool_exp
  ): [storages!]!

  """
  fetch data from the table: "system.roles"
  """
  system_roles(
    """distinct select on columns"""
    distinct_on: [system_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_roles_order_by!]

    """filter the rows returned"""
    where: system_roles_bool_exp
  ): [system_roles!]!

  """
  fetch aggregated fields from the table: "system.roles"
  """
  system_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [system_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_roles_order_by!]

    """filter the rows returned"""
    where: system_roles_bool_exp
  ): system_roles_aggregate!

  """fetch data from the table: "system.roles" using primary key columns"""
  system_roles_by_pk(id: Int!): system_roles

  """
  fetch data from the table in a streaming manner: "system.roles"
  """
  system_roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [system_roles_stream_cursor_input]!

    """filter the rows returned"""
    where: system_roles_bool_exp
  ): [system_roles!]!

  """
  fetch data from the table: "system.users"
  """
  system_users(
    """distinct select on columns"""
    distinct_on: [system_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_users_order_by!]

    """filter the rows returned"""
    where: system_users_bool_exp
  ): [system_users!]!

  """
  fetch aggregated fields from the table: "system.users"
  """
  system_users_aggregate(
    """distinct select on columns"""
    distinct_on: [system_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_users_order_by!]

    """filter the rows returned"""
    where: system_users_bool_exp
  ): system_users_aggregate!

  """fetch data from the table: "system.users" using primary key columns"""
  system_users_by_pk(id: uuid!): system_users

  """
  fetch data from the table in a streaming manner: "system.users"
  """
  system_users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [system_users_stream_cursor_input]!

    """filter the rows returned"""
    where: system_users_bool_exp
  ): [system_users!]!

  """An array relationship"""
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """An aggregate relationship"""
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "vehicles" using primary key columns"""
  vehicles_by_pk(id: Int!): vehicles

  """
  fetch data from the table in a streaming manner: "vehicles"
  """
  vehicles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [vehicles_stream_cursor_input]!

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!
}

"""User's Roles"""
type system_roles {
  code: String!
  id: Int!
  name: String!
}

"""
aggregated selection of "system.roles"
"""
type system_roles_aggregate {
  aggregate: system_roles_aggregate_fields
  nodes: [system_roles!]!
}

"""
aggregate fields of "system.roles"
"""
type system_roles_aggregate_fields {
  avg: system_roles_avg_fields
  count(columns: [system_roles_select_column!], distinct: Boolean): Int!
  max: system_roles_max_fields
  min: system_roles_min_fields
  stddev: system_roles_stddev_fields
  stddev_pop: system_roles_stddev_pop_fields
  stddev_samp: system_roles_stddev_samp_fields
  sum: system_roles_sum_fields
  var_pop: system_roles_var_pop_fields
  var_samp: system_roles_var_samp_fields
  variance: system_roles_variance_fields
}

"""aggregate avg on columns"""
type system_roles_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "system.roles". All fields are combined with a logical 'AND'.
"""
input system_roles_bool_exp {
  _and: [system_roles_bool_exp!]
  _not: system_roles_bool_exp
  _or: [system_roles_bool_exp!]
  code: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "system.roles"
"""
enum system_roles_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  roles_code_key

  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey
}

"""
input type for incrementing numeric columns in table "system.roles"
"""
input system_roles_inc_input {
  id: Int
}

"""
input type for inserting data into table "system.roles"
"""
input system_roles_insert_input {
  code: String
  id: Int
  name: String
}

"""aggregate max on columns"""
type system_roles_max_fields {
  code: String
  id: Int
  name: String
}

"""aggregate min on columns"""
type system_roles_min_fields {
  code: String
  id: Int
  name: String
}

"""
response of any mutation on the table "system.roles"
"""
type system_roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [system_roles!]!
}

"""
input type for inserting object relation for remote table "system.roles"
"""
input system_roles_obj_rel_insert_input {
  data: system_roles_insert_input!

  """upsert condition"""
  on_conflict: system_roles_on_conflict
}

"""
on_conflict condition type for table "system.roles"
"""
input system_roles_on_conflict {
  constraint: system_roles_constraint!
  update_columns: [system_roles_update_column!]! = []
  where: system_roles_bool_exp
}

"""Ordering options when selecting data from "system.roles"."""
input system_roles_order_by {
  code: order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: system.roles"""
input system_roles_pk_columns_input {
  id: Int!
}

"""
select columns of table "system.roles"
"""
enum system_roles_select_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "system.roles"
"""
input system_roles_set_input {
  code: String
  id: Int
  name: String
}

"""aggregate stddev on columns"""
type system_roles_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type system_roles_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type system_roles_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "system_roles"
"""
input system_roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: system_roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input system_roles_stream_cursor_value_input {
  code: String
  id: Int
  name: String
}

"""aggregate sum on columns"""
type system_roles_sum_fields {
  id: Int
}

"""
update columns of table "system.roles"
"""
enum system_roles_update_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  name
}

input system_roles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: system_roles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: system_roles_set_input

  """filter the rows which have to be updated"""
  where: system_roles_bool_exp!
}

"""aggregate var_pop on columns"""
type system_roles_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type system_roles_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type system_roles_variance_fields {
  id: Float
}

"""
columns and relationships of "system.users"
"""
type system_users {
  ci: String!
  created_at: timestamptz!
  first_name: String!
  id: uuid!
  last_name: String!
  password: String!
  phone: String!

  """An object relationship"""
  role: system_roles!
  role_id: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "system.users"
"""
type system_users_aggregate {
  aggregate: system_users_aggregate_fields
  nodes: [system_users!]!
}

"""
aggregate fields of "system.users"
"""
type system_users_aggregate_fields {
  avg: system_users_avg_fields
  count(columns: [system_users_select_column!], distinct: Boolean): Int!
  max: system_users_max_fields
  min: system_users_min_fields
  stddev: system_users_stddev_fields
  stddev_pop: system_users_stddev_pop_fields
  stddev_samp: system_users_stddev_samp_fields
  sum: system_users_sum_fields
  var_pop: system_users_var_pop_fields
  var_samp: system_users_var_samp_fields
  variance: system_users_variance_fields
}

"""aggregate avg on columns"""
type system_users_avg_fields {
  role_id: Float
}

"""
Boolean expression to filter rows from the table "system.users". All fields are combined with a logical 'AND'.
"""
input system_users_bool_exp {
  _and: [system_users_bool_exp!]
  _not: system_users_bool_exp
  _or: [system_users_bool_exp!]
  ci: String_comparison_exp
  created_at: timestamptz_comparison_exp
  first_name: String_comparison_exp
  id: uuid_comparison_exp
  last_name: String_comparison_exp
  password: String_comparison_exp
  phone: String_comparison_exp
  role: system_roles_bool_exp
  role_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "system.users"
"""
enum system_users_constraint {
  """
  unique or primary key constraint on columns "ci"
  """
  users_ci_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for incrementing numeric columns in table "system.users"
"""
input system_users_inc_input {
  role_id: Int
}

"""
input type for inserting data into table "system.users"
"""
input system_users_insert_input {
  ci: String
  created_at: timestamptz
  first_name: String
  id: uuid
  last_name: String
  password: String
  phone: String
  role: system_roles_obj_rel_insert_input
  role_id: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type system_users_max_fields {
  ci: String
  created_at: timestamptz
  first_name: String
  id: uuid
  last_name: String
  password: String
  phone: String
  role_id: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type system_users_min_fields {
  ci: String
  created_at: timestamptz
  first_name: String
  id: uuid
  last_name: String
  password: String
  phone: String
  role_id: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "system.users"
"""
type system_users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [system_users!]!
}

"""
on_conflict condition type for table "system.users"
"""
input system_users_on_conflict {
  constraint: system_users_constraint!
  update_columns: [system_users_update_column!]! = []
  where: system_users_bool_exp
}

"""Ordering options when selecting data from "system.users"."""
input system_users_order_by {
  ci: order_by
  created_at: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  password: order_by
  phone: order_by
  role: system_roles_order_by
  role_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: system.users"""
input system_users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "system.users"
"""
enum system_users_select_column {
  """column name"""
  ci

  """column name"""
  created_at

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  password

  """column name"""
  phone

  """column name"""
  role_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "system.users"
"""
input system_users_set_input {
  ci: String
  created_at: timestamptz
  first_name: String
  id: uuid
  last_name: String
  password: String
  phone: String
  role_id: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type system_users_stddev_fields {
  role_id: Float
}

"""aggregate stddev_pop on columns"""
type system_users_stddev_pop_fields {
  role_id: Float
}

"""aggregate stddev_samp on columns"""
type system_users_stddev_samp_fields {
  role_id: Float
}

"""
Streaming cursor of the table "system_users"
"""
input system_users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: system_users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input system_users_stream_cursor_value_input {
  ci: String
  created_at: timestamptz
  first_name: String
  id: uuid
  last_name: String
  password: String
  phone: String
  role_id: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type system_users_sum_fields {
  role_id: Int
}

"""
update columns of table "system.users"
"""
enum system_users_update_column {
  """column name"""
  ci

  """column name"""
  created_at

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  password

  """column name"""
  phone

  """column name"""
  role_id

  """column name"""
  updated_at
}

input system_users_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: system_users_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: system_users_set_input

  """filter the rows which have to be updated"""
  where: system_users_bool_exp!
}

"""aggregate var_pop on columns"""
type system_users_var_pop_fields {
  role_id: Float
}

"""aggregate var_samp on columns"""
type system_users_var_samp_fields {
  role_id: Float
}

"""aggregate variance on columns"""
type system_users_variance_fields {
  role_id: Float
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""Vehicle data"""
type vehicles {
  brand: String!
  color: String!
  created_at: timestamptz!
  id: Int!
  model: String!

  """An object relationship"""
  owner: owners!
  owner_id: uuid!

  """An object relationship"""
  parking_slot: parking_slots!
  parking_slot_id: Int!
  plate: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "vehicles"
"""
type vehicles_aggregate {
  aggregate: vehicles_aggregate_fields
  nodes: [vehicles!]!
}

input vehicles_aggregate_bool_exp {
  count: vehicles_aggregate_bool_exp_count
}

input vehicles_aggregate_bool_exp_count {
  arguments: [vehicles_select_column!]
  distinct: Boolean
  filter: vehicles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "vehicles"
"""
type vehicles_aggregate_fields {
  avg: vehicles_avg_fields
  count(columns: [vehicles_select_column!], distinct: Boolean): Int!
  max: vehicles_max_fields
  min: vehicles_min_fields
  stddev: vehicles_stddev_fields
  stddev_pop: vehicles_stddev_pop_fields
  stddev_samp: vehicles_stddev_samp_fields
  sum: vehicles_sum_fields
  var_pop: vehicles_var_pop_fields
  var_samp: vehicles_var_samp_fields
  variance: vehicles_variance_fields
}

"""
order by aggregate values of table "vehicles"
"""
input vehicles_aggregate_order_by {
  avg: vehicles_avg_order_by
  count: order_by
  max: vehicles_max_order_by
  min: vehicles_min_order_by
  stddev: vehicles_stddev_order_by
  stddev_pop: vehicles_stddev_pop_order_by
  stddev_samp: vehicles_stddev_samp_order_by
  sum: vehicles_sum_order_by
  var_pop: vehicles_var_pop_order_by
  var_samp: vehicles_var_samp_order_by
  variance: vehicles_variance_order_by
}

"""
input type for inserting array relation for remote table "vehicles"
"""
input vehicles_arr_rel_insert_input {
  data: [vehicles_insert_input!]!

  """upsert condition"""
  on_conflict: vehicles_on_conflict
}

"""aggregate avg on columns"""
type vehicles_avg_fields {
  id: Float
  parking_slot_id: Float
}

"""
order by avg() on columns of table "vehicles"
"""
input vehicles_avg_order_by {
  id: order_by
  parking_slot_id: order_by
}

"""
Boolean expression to filter rows from the table "vehicles". All fields are combined with a logical 'AND'.
"""
input vehicles_bool_exp {
  _and: [vehicles_bool_exp!]
  _not: vehicles_bool_exp
  _or: [vehicles_bool_exp!]
  brand: String_comparison_exp
  color: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  model: String_comparison_exp
  owner: owners_bool_exp
  owner_id: uuid_comparison_exp
  parking_slot: parking_slots_bool_exp
  parking_slot_id: Int_comparison_exp
  plate: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "vehicles"
"""
enum vehicles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  vehicles_pkey

  """
  unique or primary key constraint on columns "plate"
  """
  vehicles_plate_key
}

"""
input type for incrementing numeric columns in table "vehicles"
"""
input vehicles_inc_input {
  id: Int
  parking_slot_id: Int
}

"""
input type for inserting data into table "vehicles"
"""
input vehicles_insert_input {
  brand: String
  color: String
  created_at: timestamptz
  id: Int
  model: String
  owner: owners_obj_rel_insert_input
  owner_id: uuid
  parking_slot: parking_slots_obj_rel_insert_input
  parking_slot_id: Int
  plate: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type vehicles_max_fields {
  brand: String
  color: String
  created_at: timestamptz
  id: Int
  model: String
  owner_id: uuid
  parking_slot_id: Int
  plate: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "vehicles"
"""
input vehicles_max_order_by {
  brand: order_by
  color: order_by
  created_at: order_by
  id: order_by
  model: order_by
  owner_id: order_by
  parking_slot_id: order_by
  plate: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type vehicles_min_fields {
  brand: String
  color: String
  created_at: timestamptz
  id: Int
  model: String
  owner_id: uuid
  parking_slot_id: Int
  plate: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "vehicles"
"""
input vehicles_min_order_by {
  brand: order_by
  color: order_by
  created_at: order_by
  id: order_by
  model: order_by
  owner_id: order_by
  parking_slot_id: order_by
  plate: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "vehicles"
"""
type vehicles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vehicles!]!
}

"""
on_conflict condition type for table "vehicles"
"""
input vehicles_on_conflict {
  constraint: vehicles_constraint!
  update_columns: [vehicles_update_column!]! = []
  where: vehicles_bool_exp
}

"""Ordering options when selecting data from "vehicles"."""
input vehicles_order_by {
  brand: order_by
  color: order_by
  created_at: order_by
  id: order_by
  model: order_by
  owner: owners_order_by
  owner_id: order_by
  parking_slot: parking_slots_order_by
  parking_slot_id: order_by
  plate: order_by
  updated_at: order_by
}

"""primary key columns input for table: vehicles"""
input vehicles_pk_columns_input {
  id: Int!
}

"""
select columns of table "vehicles"
"""
enum vehicles_select_column {
  """column name"""
  brand

  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  model

  """column name"""
  owner_id

  """column name"""
  parking_slot_id

  """column name"""
  plate

  """column name"""
  updated_at
}

"""
input type for updating data in table "vehicles"
"""
input vehicles_set_input {
  brand: String
  color: String
  created_at: timestamptz
  id: Int
  model: String
  owner_id: uuid
  parking_slot_id: Int
  plate: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type vehicles_stddev_fields {
  id: Float
  parking_slot_id: Float
}

"""
order by stddev() on columns of table "vehicles"
"""
input vehicles_stddev_order_by {
  id: order_by
  parking_slot_id: order_by
}

"""aggregate stddev_pop on columns"""
type vehicles_stddev_pop_fields {
  id: Float
  parking_slot_id: Float
}

"""
order by stddev_pop() on columns of table "vehicles"
"""
input vehicles_stddev_pop_order_by {
  id: order_by
  parking_slot_id: order_by
}

"""aggregate stddev_samp on columns"""
type vehicles_stddev_samp_fields {
  id: Float
  parking_slot_id: Float
}

"""
order by stddev_samp() on columns of table "vehicles"
"""
input vehicles_stddev_samp_order_by {
  id: order_by
  parking_slot_id: order_by
}

"""
Streaming cursor of the table "vehicles"
"""
input vehicles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: vehicles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input vehicles_stream_cursor_value_input {
  brand: String
  color: String
  created_at: timestamptz
  id: Int
  model: String
  owner_id: uuid
  parking_slot_id: Int
  plate: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type vehicles_sum_fields {
  id: Int
  parking_slot_id: Int
}

"""
order by sum() on columns of table "vehicles"
"""
input vehicles_sum_order_by {
  id: order_by
  parking_slot_id: order_by
}

"""
update columns of table "vehicles"
"""
enum vehicles_update_column {
  """column name"""
  brand

  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  model

  """column name"""
  owner_id

  """column name"""
  parking_slot_id

  """column name"""
  plate

  """column name"""
  updated_at
}

input vehicles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: vehicles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: vehicles_set_input

  """filter the rows which have to be updated"""
  where: vehicles_bool_exp!
}

"""aggregate var_pop on columns"""
type vehicles_var_pop_fields {
  id: Float
  parking_slot_id: Float
}

"""
order by var_pop() on columns of table "vehicles"
"""
input vehicles_var_pop_order_by {
  id: order_by
  parking_slot_id: order_by
}

"""aggregate var_samp on columns"""
type vehicles_var_samp_fields {
  id: Float
  parking_slot_id: Float
}

"""
order by var_samp() on columns of table "vehicles"
"""
input vehicles_var_samp_order_by {
  id: order_by
  parking_slot_id: order_by
}

"""aggregate variance on columns"""
type vehicles_variance_fields {
  id: Float
  parking_slot_id: Float
}

"""
order by variance() on columns of table "vehicles"
"""
input vehicles_variance_order_by {
  id: order_by
  parking_slot_id: order_by
}

